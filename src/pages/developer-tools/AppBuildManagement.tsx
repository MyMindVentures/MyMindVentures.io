import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { ArrowLeft, Calendar, Lightbulb, Eye } from 'lucide-react';
import { Card } from '../../components/ui/Card';
import { Button } from '../../components/ui/Button';
import { Input } from '../../components/ui/Input';
import { SnippetCreator } from '../../components/build-management/SnippetCreator';
import { CommitCreator } from '../../components/build-management/CommitCreator';
import { PublicationCreator } from '../../components/build-management/PublicationCreator';
import { AutomatedSnippets } from '../../components/build-management/AutomatedSnippets';
import { TimelineView } from '../../components/build-management/TimelineView';
import { supabaseService as db } from '../../lib/supabase';
import { supabase } from '../../lib/supabase';
import { BlueprintSnippet, Commit, Publication, BlueprintFile, SpecialPage } from '../../types';

interface AppBuildManagementProps {
  onBack: () => void;
}

interface TimelineItem {
  id: string;
  type: 'blueprint_snippet' | 'commit' | 'publication' | 'blueprint_file' | 'special_page';
  title: string;
  description: string;
  timestamp: string;
  branch?: string;
  version?: string;
  themes?: string[];
  content?: string;
  metadata?: any;
}

export const AppBuildManagement: React.FC<AppBuildManagementProps> = ({ onBack }) => {
  const [timelineItems, setTimelineItems] = useState<TimelineItem[]>([]);
  const [blueprintSnippets, setBlueprintSnippets] = useState<BlueprintSnippet[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingCommit, setIsGeneratingCommit] = useState(false);
  const [generatedCommit, setGeneratedCommit] = useState<any>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState('all');
  const [activeTab, setActiveTab] = useState<'manual' | 'automated'>('manual');

  useEffect(() => {
    loadTimelineData();
  }, []);

  const loadTimelineData = async () => {
    setIsLoading(true);
    try {
      const userId = 'demo-user';
      
      const [snippetsResult, commitsResult, publicationsResult, blueprintFilesResult, specialPagesResult] = await Promise.all([
        db.getBlueprintSnippets(userId),
        db.getCommits(userId),
        db.getPublications(userId),
        db.getBlueprintFiles(userId),
        db.getSpecialPages(userId),
      ]);

      const timeline: TimelineItem[] = [];

      if (snippetsResult.data) {
        setBlueprintSnippets(snippetsResult.data);
        snippetsResult.data.forEach(snippet => {
          timeline.push({
            id: snippet.id,
            type: 'blueprint_snippet',
            title: snippet.title || `Blueprint Snippet - ${snippet.themes.join(', ')}`,
            description: snippet.snippet.substring(0, 150) + '...',
            timestamp: snippet.timestamp,
            branch: snippet.branch,
            themes: snippet.themes,
            content: snippet.snippet,
          });
        });
      }

      if (commitsResult.data) {
        commitsResult.data.forEach(commit => {
          timeline.push({
            id: commit.id,
            type: 'commit',
            title: commit.title,
            description: commit.description,
            timestamp: commit.timestamp,
            branch: commit.branch,
            metadata: { 
              full_summary: commit.full_summary, 
              snippet_ids: commit.snippet_ids 
            },
          });
        });
      }

      if (publicationsResult.data) {
        publicationsResult.data.forEach(publication => {
          timeline.push({
            id: publication.id,
            type: 'publication',
            title: publication.title || `Version ${publication.version}`,
            description: publication.description || `Published version ${publication.version}`,
            timestamp: publication.date,
            version: publication.version,
            metadata: { commit_id: publication.commit_id },
          });
        });
      }

      if (blueprintFilesResult.data) {
        blueprintFilesResult.data.forEach(file => {
          timeline.push({
            id: file.id,
            type: 'blueprint_file',
            title: 'AI-Generated Complete Blueprint',
            description: file.analysis_summary || 'Complete application blueprint generated by AI',
            timestamp: file.timestamp,
            content: file.content,
            metadata: { generated_from_commit_id: file.generated_from_commit_id },
          });
        });
      }

      if (specialPagesResult.data) {
        specialPagesResult.data.forEach(page => {
          timeline.push({
            id: page.id,
            type: 'special_page',
            title: `${page.page_type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} Updated`,
            description: page.analysis_summary || `${page.page_type} documentation updated`,
            timestamp: page.updated_at,
            content: page.content,
            metadata: { 
              page_type: page.page_type,
              last_commit_analyzed: page.last_commit_analyzed 
            },
          });
        });
      }

      timeline.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
      setTimelineItems(timeline);

    } catch (error) {
      console.error('Error loading timeline data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const generateSnippetTitle = (themes: string[], content: string) => {
    // Generate title based on content keywords
    const words = content.toLowerCase().split(' ');
    const keywords = ['component', 'function', 'feature', 'ui', 'api', 'database', 'style', 'layout'];
    const foundKeyword = keywords.find(keyword => words.includes(keyword));
    
    if (foundKeyword) {
      return `${foundKeyword.charAt(0).toUpperCase() + foundKeyword.slice(1)} Implementation`;
    }
    
    return 'Blueprint Snippet';
  };

  const handleCreateSnippet = async (content: string, title: string, timestamp: string) => {
    setIsGenerating(true);
    try {
      const { data } = await db.createBlueprintSnippet({
        timestamp,
        branch: 'main',
        snippet: content,
        title,
        themes: [],
        user_id: 'demo-user',
      });

      if (data) {
        await db.createBuildLogEntry({
          action_type: 'blueprint_snippet',
          action_description: `Created blueprint snippet: ${title}`,
          timestamp,
          user_id: 'demo-user',
          related_id: data.id,
          metadata: { branch: 'main' },
        });
        
        loadTimelineData();
      }
    } catch (error) {
      console.error('Error creating snippet:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleGenerateCommit = async () => {
    setIsGeneratingCommit(true);
    try {
      const apiUrl = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/generate-commit`;
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id: 'demo-user',
          branch: 'main',
        }),
      });

      const result = await response.json();
      
      if (result.success) {
        setGeneratedCommit(result.commit_data);
      } else {
        console.error('AI commit generation failed:', result.message);
        alert(`AI generation failed: ${result.message}. Please create commit manually.`);
      }
    } catch (error) {
      console.error('Error generating commit:', error);
      alert('Failed to generate commit. Please try again or create manually.');
    } finally {
      setIsGeneratingCommit(false);
    }
  };

  const handleCreateCommit = async (title: string, description: string, summary: string) => {
    setIsGenerating(true);
    try {
      const timestamp = new Date().toISOString();
      
      const { data: uncommittedSnippets } = await db.getUncommittedSnippets('demo-user', currentBranch);
      const snippetIds = uncommittedSnippets?.map(s => s.id) || [];
      
      const { data: commitData } = await db.createCommit({
        timestamp,
        branch: 'main',
        title,
        description,
        full_summary: summary,
        snippet_ids: snippetIds,
        user_id: 'demo-user',
      });

      if (commitData) {
        await triggerAIAnalysis(commitData.id);
        setGeneratedCommit(null);
        loadTimelineData();
      }
    } catch (error) {
      console.error('Error creating commit:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleCreatePublication = async (version: string, title: string, description: string) => {
    setIsGenerating(true);
    try {
      const { data } = await db.createPublication({
        date: new Date().toISOString(),
        version,
        title: title || `Version ${version}`,
        description,
        user_id: 'demo-user',
      });

      if (data) {
        loadTimelineData();
      }
    } catch (error) {
      console.error('Error creating publication:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  const triggerAIAnalysis = async (commitId: string) => {
    try {
      const apiUrl = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/ai-analysis`;
      
      const blueprintResponse = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: 'blueprint_file',
          commit_id: commitId,
          user_id: 'demo-user',
        }),
      });

      const blueprintResult = await blueprintResponse.json();
      
      if (blueprintResult.success) {
        await db.createBlueprintFile({
          timestamp: new Date().toISOString(),
          content: blueprintResult.content,
          generated_from_commit_id: commitId,
          analysis_summary: blueprintResult.analysis_summary,
          user_id: 'demo-user',
        });
      }

      const specialPageTypes = ['app_architecture', 'userflow_pipelines', 'database_management', 'toolstack_overview', 'user_guide'];
      
      for (const pageType of specialPageTypes) {
        const pageResponse = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            type: 'special_page',
            commit_id: commitId,
            page_type: pageType,
            user_id: 'demo-user',
          }),
        });

        const pageResult = await pageResponse.json();
        
        if (pageResult.success) {
          await db.createOrUpdateSpecialPage({
            page_type: pageType,
            title: `${pageType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} - Updated`,
            content: pageResult.content,
            analysis_summary: pageResult.analysis_summary,
            last_commit_analyzed: commitId,
            timestamp: new Date().toISOString(),
            user_id: 'demo-user',
          });
        }
      }
    } catch (error) {
      console.error('Error in AI analysis:', error);
    }
  };

  const handleDeleteMultipleItems = async (itemsToDelete: { id: string; type: string }[]) => {
    try {
      for (const item of itemsToDelete) {
        let result;
        
        switch (item.type) {
          case 'blueprint_snippet':
            result = await supabase
              .from('blueprint_snippets')
              .delete()
              .eq('id', item.id)
              .select()
              .single();
            break;
          case 'commit':
            // When deleting a commit, also unmark associated snippets
            const { data: commitData } = await supabase
              .from('commits')
              .select('snippet_ids')
              .eq('id', item.id)
              .single();
            
            if (commitData?.snippet_ids) {
              await supabase
                .from('blueprint_snippets')
                .update({ committed_at: null, commit_id: null })
                .in('id', commitData.snippet_ids);
            }
            
            result = await supabase
              .from('commits')
              .delete()
              .eq('id', item.id)
              .select()
              .single();
            break;
          case 'publication':
            result = await supabase
              .from('publications')
              .delete()
              .eq('id', item.id)
              .select()
              .single();
            break;
          case 'blueprint_file':
            result = await supabase
              .from('blueprint_files')
              .delete()
              .eq('id', item.id)
              .select()
              .single();
            break;
          case 'special_page':
            result = await supabase
              .from('special_pages')
              .delete()
              .eq('id', item.id)
              .select()
              .single();
            break;
          default:
            throw new Error(`Unknown timeline item type: ${item.type}`);
        }

        if (result.error) {
          throw result.error;
        }

        // Log the deletion
        await db.createBuildLogEntry({
          action_type: `${item.type}_deleted`,
          action_description: `Bulk deleted ${item.type.replace('_', ' ')}: ${result.data?.title || 'Item'}`,
          timestamp: new Date().toISOString(),
          user_id: 'demo-user',
          related_id: item.id,
          metadata: { type: item.type, deleted_item: result.data, bulk_operation: true },
        });
      }

      // Reload timeline data
      loadTimelineData();
    } catch (error) {
      console.error('Error deleting multiple items:', error);
      throw error;
    }
  };

  const filteredTimelineItems = timelineItems.filter(item => {
    const matchesSearch = item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         item.description.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = filterType === 'all' || item.type === filterType;
    return matchesSearch && matchesFilter;
  });

  const pendingSnippetsCount = blueprintSnippets.filter(s => !s.committed_at).length;

  return (
    <motion.div
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      className="space-y-6"
    >
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <Button variant="ghost" onClick={onBack} className="p-2">
            <ArrowLeft className="w-5 h-5" />
          </Button>
          <div>
            <h1 className="text-2xl font-bold text-white">App Build Management</h1>
            <p className="text-gray-400">Manage blueprint snippets, commits, and publications</p>
          </div>
        </div>
        
        <div className="flex items-center space-x-6">
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-yellow-400 rounded-full" />
            <span className="text-gray-400">{pendingSnippetsCount} Snippets</span>
          </div>
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-purple-400 rounded-full" />
            <span className="text-gray-400">{timelineItems.filter(i => i.type === 'commit').length} Commits</span>
          </div>
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-green-400 rounded-full" />
            <span className="text-gray-400">{timelineItems.filter(i => i.type === 'publication').length} Published</span>
          </div>
        </div>
      </div>

      {/* Tab Navigation */}
      <div className="flex space-x-2 bg-gray-800/30 p-1 rounded-lg">
        {[
          { id: 'manual', label: 'Manual Creation', icon: Lightbulb },
          { id: 'automated', label: 'Automated Monitoring', icon: Eye },
        ].map((tab) => {
          const Icon = tab.icon;
          return (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as any)}
              className={`flex items-center space-x-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                activeTab === tab.id
                  ? 'bg-cyan-500/20 text-cyan-300'
                  : 'text-gray-400 hover:text-white hover:bg-gray-700/30'
              }`}
            >
              <Icon className="w-4 h-4" />
              <span>{tab.label}</span>
            </button>
          );
        })}
      </div>

      {/* Creation Forms */}
      {activeTab === 'manual' ? (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <SnippetCreator
            onCreateSnippet={handleCreateSnippet}
            isGenerating={isGenerating}
          />

          <CommitCreator
            onGenerateCommit={handleGenerateCommit}
            onCreateCommit={handleCreateCommit}
            isGeneratingCommit={isGeneratingCommit}
            isCreating={isGenerating}
            generatedCommit={generatedCommit}
            pendingSnippetsCount={pendingSnippetsCount}
            currentBranch="main"
          />

          <PublicationCreator
            onCreatePublication={handleCreatePublication}
            isGenerating={isGenerating}
          />
        </div>
      ) : (
        <AutomatedSnippets
          currentBranch="main"
          onSnippetCreated={loadTimelineData}
        />
      )}

      {/* Timeline Filters */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <Input
            value={searchTerm}
            onChange={setSearchTerm}
            placeholder="Search timeline..."
            className="w-64"
          />
          <select
            value={filterType}
            onChange={(e) => setFilterType(e.target.value)}
            className="px-4 py-2 bg-gray-800/50 border border-gray-700/50 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500/50"
          >
            <option value="all">All Items</option>
            <option value="blueprint_snippet">Blueprint Snippets</option>
            <option value="commit">Commits</option>
            <option value="blueprint_file">AI Blueprints</option>
            <option value="special_page">Special Pages</option>
            <option value="publication">Publications</option>
          </select>
        </div>
        
        <div className="flex items-center space-x-2 text-sm text-gray-400">
          <Calendar className="w-4 h-4" />
          <span>{filteredTimelineItems.length} items</span>
        </div>
      </div>

      {/* Unified Timeline */}
      <Card title="Development Timeline" gradient>
        <TimelineView 
          items={filteredTimelineItems} 
          isLoading={isLoading}
          onUpdateItem={handleUpdateTimelineItem}
          onDeleteItem={handleDeleteTimelineItem}
          onDeleteMultipleItems={handleDeleteMultipleItems}
        />
      </Card>
    </motion.div>
  );

  async function handleUpdateTimelineItem(id: string, type: string, updates: any) {
    try {
      let result;
      
      switch (type) {
        case 'blueprint_snippet':
          result = await supabase
            .from('blueprint_snippets')
            .update(updates)
            .eq('id', id)
            .select()
            .single();
          break;
        case 'commit':
          result = await supabase
            .from('commits')
            .update(updates)
            .eq('id', id)
            .select()
            .single();
          break;
        case 'publication':
          result = await supabase
            .from('publications')
            .update(updates)
            .eq('id', id)
            .select()
            .single();
          break;
        case 'blueprint_file':
          result = await supabase
            .from('blueprint_files')
            .update(updates)
            .eq('id', id)
            .select()
            .single();
          break;
        case 'special_page':
          result = await supabase
            .from('special_pages')
            .update(updates)
            .eq('id', id)
            .select()
            .single();
          break;
        default:
          throw new Error(`Unknown timeline item type: ${type}`);
      }

      if (result.error) {
        throw result.error;
      }

      // Log the update
      await db.createBuildLogEntry({
        action_type: `${type}_updated`,
        action_description: `Updated ${type.replace('_', ' ')}: ${updates.title || 'Untitled'}`,
        timestamp: new Date().toISOString(),
        user_id: 'demo-user',
        related_id: id,
        metadata: { type, updates },
      });

      // Reload timeline data
      loadTimelineData();
    } catch (error) {
      console.error('Error updating timeline item:', error);
      throw error;
    }
  }


  async function handleDeleteTimelineItem(id: string, type: string) {
    try {
      let result;
      
      switch (type) {
        case 'blueprint_snippet':
          result = await supabase
            .from('blueprint_snippets')
            .delete()
            .eq('id', id)
            .select()
            .single();
          break;
        case 'commit':
          // When deleting a commit, also unmark associated snippets
          const { data: commitData } = await supabase
            .from('commits')
            .select('snippet_ids')
            .eq('id', id)
            .single();
          
          if (commitData?.snippet_ids) {
            await supabase
              .from('blueprint_snippets')
              .update({ committed_at: null, commit_id: null })
              .in('id', commitData.snippet_ids);
          }
          
          result = await supabase
            .from('commits')
            .delete()
            .eq('id', id)
            .select()
            .single();
          break;
        case 'publication':
          result = await supabase
            .from('publications')
            .delete()
            .eq('id', id)
            .select()
            .single();
          break;
        case 'blueprint_file':
          result = await supabase
            .from('blueprint_files')
            .delete()
            .eq('id', id)
            .select()
            .single();
          break;
        case 'special_page':
          result = await supabase
            .from('special_pages')
            .delete()
            .eq('id', id)
            .select()
            .single();
          break;
        default:
          throw new Error(`Unknown timeline item type: ${type}`);
      }

      if (result.error) {
        throw result.error;
      }

      // Log the deletion
      await db.createBuildLogEntry({
        action_type: `${type}_deleted`,
        action_description: `Deleted ${type.replace('_', ' ')}: ${result.data?.title || 'Item'}`,
        timestamp: new Date().toISOString(),
        user_id: 'demo-user',
        related_id: id,
        metadata: { type, deleted_item: result.data },
      });

      // Reload timeline data
      loadTimelineData();
    } catch (error) {
      console.error('Error deleting timeline item:', error);
      throw error;
    }
  };
};